(()=>{"use strict";var e={312:function(e,t,n){var i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const r=i(n(862)),a=document.getElementById("gfx"),{width:s,height:o}=a.getBoundingClientRect(),u=window.devicePixelRatio;a.width=s*u,a.height=o*u;const d=new ResizeObserver((e=>{for(const t of e)if(t.target===a){const e=window.devicePixelRatio,{width:n,height:i}=t.contentRect;a.width=n*e,a.height=i*e}}));d.observe(a,{box:"device-pixel-content-box"}),new r.default(a).start()},862:function(e,t,n){var i=this&&this.__awaiter||function(e,t,n,i){return new(n||(n=Promise))((function(r,a){function s(e){try{u(i.next(e))}catch(e){a(e)}}function o(e){try{u(i.throw(e))}catch(e){a(e)}}function u(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,o)}u((i=i.apply(e,t||[])).next())}))},r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});const a=r(n(861)),s=r(n(535)),o=r(n(600)),u={vertices:new Float32Array([1,-1,0,-1,-1,0,-1,1,0,1,1,0]),uvs:new Float32Array([1,1,0,1,0,0,1,0]),indices:new Uint16Array([0,1,2,2,3,0])},d=(e,t,n)=>{let i={size:t.byteLength+3&-4,usage:n,mappedAtCreation:!0},r=e.createBuffer(i);return(t instanceof Uint16Array?new Uint16Array(r.getMappedRange()):new Float32Array(r.getMappedRange())).set(t),r.unmap(),r},l=512,f=Math.ceil(4);t.default=class{constructor(e){this.previousFrameTimestamp=0,this.pingpong=0,this.render=(e=0)=>{const t=Math.min(17,e-this.previousFrameTimestamp)/1e3;this.previousFrameTimestamp=e,this.simParamValues.set([Math.random(),t]),this.device.queue.writeBuffer(this.simParamBuffer,0,this.simParamValues);const n=this.device.createCommandEncoder();this.encodeDecayCommands(n),this.encodeAgentComputeCommands(n),this.encodeBlitCommands(n),this.device.queue.submit([n.finish()]),this.pingpong=this.pingpong?0:1,requestAnimationFrame(this.render)},this.canvas=e}start(){return i(this,void 0,void 0,(function*(){(yield this.initializeAPI())&&(this.resizeBackings(),this.initializeSimParams(),this.initializeBlitResources(),this.initializeAgentResources(),this.render())}))}initializeAPI(){return i(this,void 0,void 0,(function*(){try{const e=navigator.gpu;if(!e)return!1;this.adapter=yield e.requestAdapter(),this.device=yield this.adapter.requestDevice({requiredFeatures:["float32-filterable"]}),this.queue=this.device.queue}catch(e){return console.error(e),!1}return!0}))}initializeSimParams(){this.simParamValues=new Float32Array([Math.random(),.0166]),this.simParamBuffer=d(this.device,this.simParamValues,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.simParamsUniformLayout=this.device.createBindGroupLayout({label:"AgentSimParams",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.FRAGMENT,buffer:{type:"uniform",minBindingSize:8}}]}),this.simParamBindGroup=this.device.createBindGroup({label:"SimParamUniforms",layout:this.simParamsUniformLayout,entries:[{binding:0,resource:{buffer:this.simParamBuffer}}]})}initializeAgentResources(){const e=new Float32Array(1024);for(let t=0;t<1024;t+=4)e[t+0]=Math.random()*l,e[t+1]=Math.random()*l,e[t+2]=2*Math.random()*Math.PI,e[t+3]=0;this.agentBuffers=[{buffer:d(this.device,e,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE)},{buffer:d(this.device,e,GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE)}];const t=this.device.createShaderModule({code:s.default}),n=this.device.createShaderModule({code:o.default}),i=this.device.createBindGroupLayout({label:"AgentFieldBindGroup",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]}),r=this.device.createPipelineLayout({bindGroupLayouts:[this.simParamsUniformLayout,i]}),a=new Float32Array(1048576);a.fill(0);const u={label:"AgentFieldTexture",size:[l,l,1],usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING,format:"rgba32float"},f=this.device.createSampler(),c=()=>{const e=this.device.createTexture(u),t=e.createView(),n=this.device.createBindGroup({label:"AgentFieldBindGroup",layout:i,entries:[{binding:0,resource:f},{binding:1,resource:t}]});return this.device.queue.writeTexture({texture:e},a,{bytesPerRow:8192},{width:l,height:l}),{texture:e,view:t,bindGroup:n}};this.agentFieldTextures=[c(),c()];const g={label:"DecayPipeline",layout:r,vertex:{module:t,entryPoint:"vs_main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:12,stepMode:"vertex"},{attributes:[{shaderLocation:1,offset:0,format:"float32x2"}],arrayStride:8,stepMode:"vertex"}]},fragment:{module:t,entryPoint:"fs_main",targets:[{format:"rgba32float"}]},primitive:{frontFace:"cw",cullMode:"none",topology:"triangle-list"}};this.agentFieldPipeline=this.device.createRenderPipeline(g);const p=this.device.createBindGroupLayout({label:"AgentUpdate",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage",minBindingSize:4096}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage",minBindingSize:4096}},{binding:2,visibility:GPUShaderStage.COMPUTE,texture:{viewDimension:"2d"}},{binding:3,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba32float",viewDimension:"2d"}}]});this.agentBindGroups=new Array(2).fill(0).map(((e,t)=>{const n=this.agentFieldTextures[t],i=this.agentFieldTextures[(t+1)%2],r=this.agentBuffers[t],a=this.agentBuffers[(t+1)%2];return{bindGroup:this.device.createBindGroup({label:`AgentCompute${t}`,layout:p,entries:[{binding:0,resource:{buffer:r.buffer}},{binding:1,resource:{buffer:a.buffer}},{binding:2,resource:n.view},{binding:3,resource:i.view}]})}})),this.agentComputePipeline=this.device.createComputePipeline({label:"AgentCompute",compute:{module:n,entryPoint:"compute_main"},layout:this.device.createPipelineLayout({bindGroupLayouts:[this.simParamsUniformLayout,p]})})}initializeBlitResources(){this.unitSquare={positionBuffer:d(this.device,u.vertices,GPUBufferUsage.VERTEX),uvBuffer:d(this.device,u.uvs,GPUBufferUsage.VERTEX),indexBuffer:d(this.device,u.indices,GPUBufferUsage.INDEX)},this.blitModule=this.device.createShaderModule({code:a.default});const e={bindGroupLayouts:[this.device.createBindGroupLayout({label:"BlitBindGroupLayout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]})]},t=this.device.createPipelineLayout(e),n={module:this.blitModule,entryPoint:"vs_main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:12,stepMode:"vertex"},{attributes:[{shaderLocation:1,offset:0,format:"float32x2"}],arrayStride:8,stepMode:"vertex"}]},i={format:navigator.gpu.getPreferredCanvasFormat()},r={label:"BlitPipeline",layout:t,vertex:n,fragment:{module:this.blitModule,entryPoint:"fs_main",targets:[i]},primitive:{frontFace:"cw",cullMode:"none",topology:"triangle-list"}};this.pipeline=this.device.createRenderPipeline(r)}resizeBackings(){if(!this.context){this.context=this.canvas.getContext("webgpu");const e={device:this.device,format:navigator.gpu.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"opaque"};this.context.configure(e)}}encodeAgentComputeCommands(e){const t=e.beginComputePass({label:"AgentCompute"});t.setPipeline(this.agentComputePipeline),t.setBindGroup(0,this.simParamBindGroup),t.setBindGroup(1,this.agentBindGroups[this.pingpong].bindGroup),t.dispatchWorkgroups(f,1,1),t.end()}encodeDecayCommands(e){const t=e.beginRenderPass({label:"DecayPass",colorAttachments:[{view:this.agentFieldTextures[(this.pingpong+1)%2].view,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});t.setPipeline(this.agentFieldPipeline),t.setViewport(0,0,l,l,0,1),t.setScissorRect(0,0,l,l),t.setBindGroup(0,this.simParamBindGroup),t.setBindGroup(1,this.agentFieldTextures[this.pingpong].bindGroup),t.setVertexBuffer(0,this.unitSquare.positionBuffer),t.setVertexBuffer(1,this.unitSquare.uvBuffer),t.setIndexBuffer(this.unitSquare.indexBuffer,"uint16"),t.drawIndexed(6,1),t.end()}encodeBlitCommands(e){const t={label:"BlitPass",colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]},n=e.beginRenderPass(t);n.setPipeline(this.pipeline),n.setViewport(0,0,this.canvas.width,this.canvas.height,0,1),n.setScissorRect(0,0,this.canvas.width,this.canvas.height),n.setBindGroup(0,this.agentFieldTextures[this.pingpong].bindGroup),n.setVertexBuffer(0,this.unitSquare.positionBuffer),n.setVertexBuffer(1,this.unitSquare.uvBuffer),n.setIndexBuffer(this.unitSquare.indexBuffer,"uint16"),n.drawIndexed(6,1),n.end()}}},600:e=>{e.exports="// Compute shader\n\nstruct Agent {\n    pos: vec2<f32>,\n    angle: f32,\n    t: f32,\n};\n\nstruct SimParams {\n    randomSeed: f32,\n    deltaT: f32,\n};\n\nstruct ComputeIn {\n    @builtin(global_invocation_id) global_invocation_id: vec3<u32>,\n};\n\n@group(0) @binding(0) var<uniform> params : SimParams;\n@group(1) @binding(0) var<storage, read> agentsSrc : array<Agent>;\n@group(1) @binding(1) var<storage, read_write> agentsDst : array<Agent>;\n@group(1) @binding(2) var fieldSrc : texture_2d<f32>;\n@group(1) @binding(3) var fieldDst : texture_storage_2d<rgba32float, write>;\n\nconst PI: f32 = 3.14159274;\nconst TWO_PI: f32 = 6.28318548;\nconst AGENT_FIELD_SIZE: f32 = 512.0;\nconst AGENT_SPEED: f32 = AGENT_FIELD_SIZE / 10.0; // field units/second\nconst AGENT_TURN_SPEED: f32 = PI * 2; // Radians per second\nconst SENSOR_ANGLE: f32 = PI / 180 * 50; // Radians\nconst SENSOR_LENGTH: f32 = 5; // field units\nconst SENSOR_SIZE: i32 = 2; // field units\nconst FIELD_MIN: vec2<f32> = vec2(0.0);\nconst FIELD_MAX: vec2<f32> = vec2(AGENT_FIELD_SIZE);\n\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfn rand(n: f32) -> f32 {\n    return fract(sin(n + params.randomSeed) * 43758.5453123);\n}\n\nfn random_angle(in: f32) -> f32 {\n    return rand(in) * TWO_PI;\n}\n\nfn velocity_from_angle(angle: f32) -> vec2<f32> {\n    return vec2<f32>(\n        cos(angle),\n        sin(angle),\n    ) * AGENT_SPEED;\n}\n\nfn sense(agent: Agent, angle_offset: f32) -> f32 {\n    var angle = agent.angle + angle_offset;\n    var direction = vec2f(cos(angle), sin(angle));\n    var sensor_center = agent.pos + direction * SENSOR_LENGTH;\n\n    var sum = 0.0;\n    for (var i = -SENSOR_SIZE; i <= SENSOR_SIZE; i++) {\n        for (var j = -SENSOR_SIZE; j <= SENSOR_SIZE; j++) {\n            var pos = sensor_center + vec2f(f32(i), f32(j));\n\n            sum += textureLoad(fieldSrc, vec2<u32>(pos), 0).r;\n        }\n    }\n\n    return sum;\n}\n\n@compute\n@workgroup_size(64)\nfn compute_main(in: ComputeIn) {\n    let total = arrayLength(&agentsSrc);\n    let index = in.global_invocation_id.x;\n    // TODO: What is this guarding against?\n    if index >= total {\n        return;\n    }\n\n    var agent = agentsSrc[index];\n    var pos = agent.pos;\n    var angle = agent.angle;\n    var rand_seed = angle + pos.x + pos.y + f32(in.global_invocation_id.x);\n\n    // Sense trails\n    var forwardWeight = sense(agent, 0);\n    var leftWeight = sense(agent, SENSOR_ANGLE);\n    var rightWeight = sense(agent, -SENSOR_ANGLE);\n\n    var steeringStrength = rand(rand_seed);\n\n    if forwardWeight > leftWeight && forwardWeight > rightWeight {\n        // Do nothing\n    } else if forwardWeight < leftWeight && forwardWeight > rightWeight {\n        // Turn randomly\n        angle += (steeringStrength - 0.5) * 2 * AGENT_TURN_SPEED * params.deltaT;\n    } else if rightWeight > leftWeight {\n        // Turn right\n        angle -= steeringStrength * AGENT_TURN_SPEED * params.deltaT;\n    } else if leftWeight > rightWeight {\n        // Turn left\n        angle += steeringStrength * AGENT_TURN_SPEED * params.deltaT;\n    }\n\n    // Move agent\n    pos += velocity_from_angle(angle) * params.deltaT;\n\n    // Keep particles in bounds\n    if pos.x < 0 || pos.x > AGENT_FIELD_SIZE || pos.y < 0 || pos.y > AGENT_FIELD_SIZE {\n        pos = clamp(pos, FIELD_MIN, FIELD_MAX); // Reset position and pick a new angle\n\n        // Random bounce angle\n        angle = random_angle(rand_seed);\n    }\n\n    // Update agent\n    agentsDst[index] = Agent(pos, angle, 0);\n\n    // Write data to field\n    // textureStore(fieldDst, vec2<u32>(12, 12), vec4<f32>(1.0));\n    // textureStore(fieldDst, vec2<i32>(pos), vec4(vec3f(1.0, leftWeight, rightWeight), 1.0));\n    textureStore(fieldDst, vec2<i32>(pos), vec4(vec3f(1.0, leftWeight, rightWeight), 1.0));\n}\n"},861:e=>{e.exports="struct VertexInput {\n    @location(0) pos: vec3f,\n    @location(1) uv: vec2f,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4f,\n    @location(0) uv: vec2f,\n };\n\n@vertex\nfn vs_main(in: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n\n    out.pos = vec4f(in.pos, 1);\n    out.uv = in.uv;\n\n    return out;\n}\n\n@group(0) @binding(0) var fieldSampler: sampler;\n@group(0) @binding(1) var fieldTexture: texture_2d<f32>;\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4f {\n    return vec4(textureSample(fieldTexture, fieldSampler, in.uv).rgb, 1.0);\n}\n"},535:e=>{e.exports="struct VertexInput {\n    @location(0) pos: vec3f,\n    @location(1) uv: vec2f,\n}\n\nstruct VertexOutput {\n    @builtin(position) pos: vec4f,\n    @location(0) uv: vec2f,\n };\n\n@vertex\nfn vs_main(in: VertexInput) -> VertexOutput {\n    var out: VertexOutput;\n\n    out.pos = vec4f(in.pos, 1);\n    out.uv = in.uv;\n\n    return out;\n}\n\nstruct SimParams {\n    randomSeed: f32,\n    deltaT: f32,\n};\n\n@group(0) @binding(0) var<uniform> params : SimParams;\n\n@group(1) @binding(0) var fieldSampler: sampler;\n@group(1) @binding(1) var fieldTexture: texture_2d<f32>;\n\nconst DECAY_RATE = 0.1; // units/second\n\n@fragment\nfn fs_main(in: VertexOutput) -> @location(0) vec4f {\n    var pixelStep = vec2(1.0) / vec2f(textureDimensions(fieldTexture));\n\n    var color_out = vec4f();\n\n    // Diffusion 3x3 blur\n    var sum = vec4f();\n    for (var i = -1; i <= 1; i++) {\n        for (var j = -1; j <= 1; j++) {\n            sum += textureSample(fieldTexture, fieldSampler, in.uv + pixelStep * vec2f(f32(i), f32(j)));\n        }\n    }\n    // TODO: This should somehow be factored by time\n    color_out += sum / 9.0;\n\n    // Decay\n    color_out = clamp(color_out - vec4(DECAY_RATE) * params.deltaT, vec4(), vec4(1.0));\n\n    return color_out;\n}\n"}},t={};!function n(i){var r=t[i];if(void 0!==r)return r.exports;var a=t[i]={exports:{}};return e[i].call(a.exports,a,a.exports,n),a.exports}(312)})();